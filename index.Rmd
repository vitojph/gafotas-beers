---
title: "Herramientas de Unix y Regex"
author: "Víctor Peinado"
date: "3/08/2015"
output: ioslides_presentation
---

# *shell*, terminal, línea de comandos


Cuando abrimos una shell, terminal (o línea de comandos) en un sistema tipo Unix, nos encontramos con una interfaz como la siguiente:

```
user@mypc:~$
```

En este caso, estamos trabajando en un ordenador que se llama `mypc` y nuestro nombre de usuario es `user`.

- El ordenador suele indicar, mediante un cursor que parpadea, que queda a la espera de instrucciones.

- Esta interfaz es muy potente y nos permite (si conocemos los comandos adecuados) ejecutar y manipular cualquier proceso del sistema operativo. 


## `pwd` (*print working directory*)

Para que el sistema no indique en qué directorio estamos actualmente ejecutamos el comando `pwd`.

```
user@mypc:~$ pwd
/home/user
```

En los sistemas de tipo Unix, la unidades de disco no utilizan letras (en Windows, las distintas unidades se llaman `C:`, `D:`, `A:`, etc). La estructura jerárquica de directorios cuelga de una única raíz, indicada con la barra `/`.

El directorio de trabajo de cada usuario (el equivalente a `Mis Documentos` en Windows) cuelga siempre de `/home`.


## Rutas absolutas y rutas relativas

- Las rutas absolutas parten desde el directorio raíz `/` e indican la jerarquía completa de directorios 
hasta el lugar de destino: `/home/user/Ling/sintaxis/ejercicio1.doc`

- Las rutas relativas parten desde el directorio de trabajo actual, sea el que sea en cada momento. Si estamos en nuestro directorio de usuario: `Ling/sintaxis/ejercicio1.doc`

En la rutas relativas, utilizamos un par de símbolos especiales para representar posiciones. 

- Un punto `.` indica el directorio actual.
- Dos puntos seguidos `..` indican el nivel inmediatamente superior en la jearquía de directorios.


## `ls [ARGUMENTOS] [RUTA]` (*list*)

Para lista los nombres de los directorios y carpetas del directorio actual de trabajo, ejecutamos el comando `ls`.

Si lo ejecutamos sin especificar ruta, se asume que el directorio a listar es el directorio actual de trabajo:

```
user@mypc:~$ ls
contratos facturas
```
Si lo ejecutamos especificando el nombre de un directorio, nos listará su contenido:

```
user@mypc:~$ ls contratos
gas internet luz notas.txt
```

## `ls -l`

Si ejecutamos `ls` sin especificar ningún argumento, la información que nos muestra es escasa. Es más habitual solicitar un listado de directorios en versión larga (usando el argumento `ls -l`), que proporciona información sobre tipos de ficheros, permisos, usuarios y grupos, tamaño y fecha de la última modificación:

Si listamos el directorio `contratos`, comprobamos que contiene tres directorios `gas, internet, luz` y un fichero de texto llamado `notas.txt`. 

```
user@mypc:~$ ls -l contratos
drwxrwxr-x 2 user group 4096 2014-05-02 17:29 gas
drwxrwxr-x 2 user group 4096 2014-05-02 17:29 internet
drwxrwxr-x 2 user group 4096 2014-05-02 17:29 luz
-rw-rw-r-- 1 user group  130 2014-05-02 17:32 notas.txt
```

## `ls -l`

- La 1ª columna indica los distintos permisos de lectura (`r`), escritura (`w`) y ejecución (`x`).
- Si el fichero es un directorio, la primera letra es siempre una `d`. Si es un fichero normal, es `-`.
- La 3ª y 4ª columna indican el propietario y el grupo de usuarios que tiene acceso a estos ficheros.
- La 5ª columna indica el tamaño en bytes. Los directorios, independientemente de su contenido, siempre *marcan* el mismo tamaño. 
- Las columnas 6ª y 7ª indican la fecha y la hora de la última modificación.
- La 8ª columna indica el nombre del fichero.


## `cd [RUTA/]DIRECTORIO` (*change dir*)

Para cambiar de directorio utilizamos el comando `cd`.

```
user@mypc:~$ pwd
/home/user
user@mypc:~$ cd contratos
user@mypc:~$ pwd
/home/user/contratos
```

## `cd`

Si no especificamos ni ruta ni directorio y ejecutamos simplemente `cd` se asume que el cambio de directorio se refiere al directorio del usuario, y volvemos a `/home/user`, estemos donde estemos.

```
user@mypc:~$ pwd
/home/user/contratos/gas/2010
user@mypc:~$ cd
user@mypc:~$ pwd
/home/user
```
## `cd [RUTA/]DIRECTORIO`

Podemos movernos a cualquier punto de la jerarquía de directorios utilizando tanto rutas absolutas o relativas. 

```
user@mypc:~$ cd contratos/gas
user@mypc:~$ pwd
/home/user/contratos/gas
user@mypc:~$ cd /usr/share/doc/java-common
user@mypc:~$ pwd
/usr/share/doc/java-common
```

## `cd [RUTA/]DIRECTORIO` (*change dir*)

Para subir un nivel (o los que sean necesarios), utilizamos el símbolo especial que hemos visto antes, los dos puntos seguidos `..`

```
user@mypc:~$ pwd
/home/user/contratos/gas
user@mypc:~$ cd ../..
user@mypc:~$ pwd
/home/user
```

# Creando directorios y ficheros

## `mkdir [RUTA/]DIR` (*make dir*)

Para crear un directorio utilizamos la instrucción `mkdir`. 

```
user@mypc:~$ ls
contratos
user@mypc:~$ mkdir papeleo
user@mypc:~$ ls
contratos papeleo
```

Podemos utilizar una ruta relativa o absoluta para crear un directorio donde queramos, sin necesidad de estar situados en el directorio que lo contiene.

```
user@mypc:~$ mkdir contratos/seguroDelCoche
user@mypc:~$ ls contratos
gas internet luz notas.txt seguroDelCoche
```

## `touch [RUTA/]FICHERO`

Para crear ficheros vacíos utilizamos el comando `touch`.

```
user@mypc:~$ touch contratos/contratosPendientes.txt
user@mypc:~$ ls contratos
contratosPendientes.txt gas internet luz notas.txt seguroDelCoche
```

## `echo "CADENA" [DESTINO]`

El comando `echo` nos permite imprimir mensajes o cadenas de texto. Las cadenas tienen que ir entrecomilladas. Si no especificamos un destino, la cadena se imprime por pantalla. 

```
user@mypc:~$ echo "OLA K ASE?"
OLA K ASE?
```

Si indicamos como destino la ruta hacia un fichero de texto a través del símbolo `>>` la cadena se concatenará al contenido de dicho fichero.

```
user@mypc:~$ echo "OLA K ASE?" >> saludo.txt
```

# Copiando, moviendo, renombrando, borrando


## `cp [RUTA/]FICHERO DESTINO` (*copy*)

Para copiar un fichero en otro directorio utilizamos el comando `cp`. 

Por ejemplo, para copiar el fichero `saludo.txt` en el nivel superior, en este ejemplo `/home/user`, ejecutamos:

```
user@mypc:~$ pwd
/home/user/contratos
user@mypc:~$ cp saludo.txt ..
```

Para especificar las rutas del fichero y el destino de la copia podemos utilizar tanto rutas relativas como absolutas, incluido el símbolo especial `..` para indicar el directorio superior.


## `mv [RUTA/]FICHERO DESTINO` (*move*)

Para mover un fichero a otro directorio utilizamos el comando `mv`. Por ejemplo, para mover el fichero `saludo.txt` desde el directorio de trabajo actual al directorio `/tmp/`, ejecutamos:

```
user@mypc:~$ mv saludo.txt /tmp/
```

## `rm [RUTA/]FICHERO` (*remove*)

Para eliminar un fichero, ejecutamos la instrucción `rm`. Por ejemplo, para borrar definitivamente el fichero `saludo.txt` que acabamos de mover a `/tmp/`, ejecutamos:

```
user@mypc:~$ rm /tmp/saludo.txt
```

## `rmdir [RUTA/]DIRECTORIO` (*remove dir*)

Para eliminar directorios, necesitamos ejecutar una instrucción específica: `rmdir`. Antes, debemos asegurarnos de que el directorio en cuestión está vacío y no contiene ficheros. Por ejemplo, para eliminar definitivamente un directorio previamente vaciado, ejecutamos:

```
user@mypc:~$ mkdir directorioBasura
user@mypc:~$ ls
directorioBasura otroDirectorio
user@mypc:~$ rmdir directorioBasura
user@mypc:~$ ls
otroDirectorio
```

# Visualizando ficheros de texto

## `cat [RUTA/]FICHERO`

Para imprimir el contenido de un fichero de texto utilizamos el comando `cat`.

```
user@mypc:~$ cat saludo.txt
OLA K ASE?
user@mypc:~$ echo "Pues mira, muy bien." >> saludo.txt
user@mypc:~$ cat saludo.txt
OLA K ASE?
Pues mira, muy bien.
```

## `less [RUTA/]FICHERO`

Para poder visualizar el contenido de un fichero de texto de manera paginada podemos utilizar `less`. 

Además de avanzar página a página podemos movernos hacia atrás en el texto utilizando las teclas de los cursores. Para salir del paginador pulsamos `q`.


## ¿Cómo busco ayuda?

No es sencillo ni necesario recordar las opciones disponibles para cada comando así que es habitual echar mano de los comandos de ayuda de la propia de la shell. 

- Todos los comandos tienen una opción `--help` (a veces también `-h`) que podemos ejecutar
  para acceder a la ayuda en formato abreviado. 

```
user@mypc:~$ cat --help 
```

- El comando `man` (de *manual*) nos da acceso al manual completo de cada
  comando.

```
user@mypc:~$ man cat
```



# Procesar ficheros de texto


## `wc [OPCIONES] [RUTA/]FICHERO` 

Para mostrar estadísticas del tamaño de un fichero de texto podemos utilizar el comando `wc`. 

Si se ejecuta sin ninguna opción, se nos muestran cuatro columnas con la siguiente información: número de líneas, número de palabras, número de caracteres y nombre del fichero.

Por ejemplo, para imprimir por pantalla las estadísticas de todos los ficheros del directorio actual que contengan la cadena `palabras' en su nombre, ejecutamos:

```
user@mypc:~$ wc palabras*
26  26 174 palabras.txt
21  42 317 palabras-unicas-ordenadas.txt
21  42 317 palabras-unicas.txt
68 110 808 total
```

## `wc` 

Entre las opciones más útiles de `wc`, están:

- `-l` imprime el número de líneas de un fichero.
- `-w` imprime el número de palabras de un fichero. 


```
user@mypc:~$ wc -l palabras.txt 
26 palabras.txt 
user@mypc:~$ wc -w palabras-unicas.txt 
42 palabras-unicas.txt 
```



## `sort [OPCIONES] [RUTA/]FICHERO`

Procesa un fichero de texto línea a línea y las muestra ordenadas. Las opciones determinan el tipo de ordenación empleado:

- `-d` orden alfabético, incluso para los números.\marginnote{Distingue entre mayúsculas y minúsculas y tiene en cuenta los posibles espacios en blanco que aparezcan}
- `-n` orden numérico: coloca los números antes que las letras y ordena los dígitos de menor a mayor.
- `-f` no distingue entre mayúsculas y minúsculas.
- `-r` orden inverso.

Las opciones se pueden combinar, p. ej., para ordenar un fichero numéricamente de mayor a menor podemos ejecutar `sort -nr FICHERO`.


## `uniq [OPCIONES] [RUTA/]FICHERO`

Procesa un fichero de texto línea a línea y elimina los duplicados, es decir, solo muestra una ocurrencia por línea. Algunas de las opciones más interesantes son:

- `-c` muestra el número de ocurrencias de cada línea.
- `-d` muestra solo las líneas duplicadas.
- `-i` ignora las diferencias entre mayúsculas y minúsculas

**Ojo**, `uniq` solo recuerda la última línea que ha visto y, en consecuencia, sólo es capaz de eliminar líneas duplicadas cuando aparecen todas juntas unas detrás de otras. Antes de eliminar líneas duplicadas es conveniente ordenarlas con `sort`.


## `grep [OPCIONES] PATRÓN FICHERO`

Procesa un fichero de texto línea a línea e imprime solo aquellas que contengan el patrón de búsqueda especificado. Entre las opciones más interesantes, están:

- `-i` ignora las diferencias entre mayúsculas y minúsculas
- `-v` invierte el sentido del patrón, es decir, muestra solo las líneas que no coincidan con el patrón.
- `-c` imprime, en lugar de las líneas, el número de ocurrencias en las que el patrón coincide. 

Por ejemplo, imprime del fichero `palabras.txt` solo aquellas líneas que contengan la cadena `mente`.

```
user@mypc:~$ grep "mente" palabras.txt 
```


## `grep`

Para realizar la operación contraria, es decir, imprimir solo aquellas líneas que no contienen la cadena `mente`, podemos utilizar `grep` con la opción `-v`.

```
user@mypc:~$ grep -v "mente" palabras.txt 
```


## `tr [OPCIONES] PATRÓN1 PATRÓN2 < FICHERO`

El comando `tr` permite procesar un fichero de texto y transformar o realizar sustituciones entre los caracteres del patrón `PATRÓN1` con los caracteres del patrón `PATRÓN2`. 

Para procesar nuestro fichero de palabras y sustituir cualquier aparición de una `m` en una `M`, ejecutamos:

```
user@mypc:~$ tr "m" "M" < palabras.txt 
```

## `tr`

Para sustituir las vocales en minúsculas a mayúsculas, ejecutamos:

```
user@mypc:~$ tr "aeiou" "AEIOU" < palabras.txt 
```

Si queremos pasar a mayúsculas un texto escrito en minúsculas, podemos especificar un rango de caracteres (de la *a* a la *z*):

```
user@mypc:~$ tr "a-z" "A-Z" < palabras.txt 
```

Para sustituir cualquier dígito que encontremos por una `X`, podemos ejecutar: 

```
user@mypc:~$ tr "0-9" "X" < palabras.txt 
```

## `tr`

Fíjate en el comportamiento de estos alias: 

- `a-z` para las letras del alfabeto en minúsculas
- `A-Z` para las letras mayúsculas
- `A-z` para el alfabeto completo en mayúsculas y minúsculas
- `0-9` para los dígitos
- o incluso subconjuntos de estos caracteres como `a-m` y `5-9`


## `tr`

Un uso muy del comando `tr` muy interesante para tareas de procesamiento de texto es utilizarlo para *tokenizar* o segmentar en palabras un fichero de texto. 

Para ello, necesitaremos especificar determinadas opciones de manera que sustityamos cualquier carácter que no sea `-c` una letra mayúscula o minúscula (`A-Za-z`) por un único (`-s`) retorno de carro (`\n`). Comprueba qué hace la siguiente intrucción:

```
user@mypc:~$ tr -sc "A-Za-z" "\n" < texto.txt > texto-tokenizado.txt
```

## `tr`

La instrucción anterior no tendrá en cuenta como palabras o *tokens* los caracteres con diacríticos propios del español o las secuencias de dígitos que encuentre. Para separar correctamente las palabras en español y considerar también como *tokens* los números, necesitamos modificar el primer patrón:

```
user@mypc:~$ tr -sc "A-Za-zÁÉÍÓÚÜáéíóúüñÑ0-9" "\n" < texto.txt > texto-tokenizado.txt
```


# Entrada, salida y *pipelines* para encadenar comandos 

## Encadenando herramientas

Hasta ahora hemos visto comandos para realizar operaciones sencillas sobre ficheros. La mayoría de las herramientas de Unix son similares: consisten en herramientas pequeñas que realizan muy bien una operación muy concreta y determinada, y funcionan de la siguiente manera: 

- toman uno o varios ficheros como entrada
- los manipulan; y 
- generan un salida, que podemos mostrar por pantalla o redirigirla a otro sitio. 

La verdadera potencia y versatilidad de estas herramientas la obtenemos cuando encadenamos unas con otras, seleccionando como entrada de una de estas instrucciones la salida de otra. Para ello podemos hacer uso de algunos símbolos especiales que veremos a continuación.


## Entrada `<` [RUTA/]FICHERO

La mayoría de los comandos de Unix que hemos visto hasta el momento toman como entrada el nombre de fichero que especifiquemos. En otros casos, es obligatorio especificar de manera explícita el fichero de entrada con el símbolo `<`.

```
user@mypc:~$ cat < palabras.txt        # equivalente a cat palabras  
user@mypc:~$ sort -nr < palabras.txt   # equivalente a sort -nr palabras.txt
user@mypc:~$ tr "a" "A" < palabras.txt # es obligatorio el uso de <
```


## Salida `>` [RUTA/]FICHERO
Hemos visto anteriormente que podemos redirigir la salida de un comando a un fichero de texto. 

Por ejemplo, para ordenar alfabéticamente el fichero `palabras.txt` y guardar el resultado en otro fichero de nueva creación llamado `palabras-ordenadas.txt`, ejecutamos la siguiente instrucción, indicando explícitamente la entrada y la salida.

```
user@mypc:~$ sort < palabras.txt > palabras-ordenadas.txt
```

Podemos redirigir la salida de dos maneras: 

- `>` redirige la salida a un fichero. Si no existe, lo crea. Si existía previamente, lo sobreescribe.
- `>>` redirige la salida a un fichero. Si no existe, lo crea. Si existe, concatena el resultado al contenido anterior.



## Tubería (*pipeline*) comando `|` comando

Como hemos visto, muchas de las herramientas de Unix toman como entrada ficheros de texto, los procesan línea a línea ejecutando tareas sencillas y generan una salida. La verdadera potencia de estas herramientas radica en la posibilidad de encadenar varias de ellas, haciendo que una herramienta tome como entrada y procese la salida de otra herramienta que hemos ejecutado previamente. El *pegamento* que nos permite encadenar herramientas desde la línea de comandos es la tubería o *pipeline* `|`.

Imaginemos que queremos procesar línea a línea una fichero de texto formado por un listado de palabras. Dicho listado contienen palabras desordenadas y numerosos duplicados. Podemos encadenar tres herramientas como `sort`, `uniq` y `grep` para generar un nuevo listado de palabras ordenadas, únicas y que contengan la cadena `mente` con el siguiente comando:

```
user@mypc:~$ sort palabras.txt | uniq | grep "mente" > ordenadas.txt
```

Podemos realizar la misma operación sin necesidad de almacenar la salida en ningún fichero. Para revisar el resultado, nos basta con redirigir la salida al paginador `less` del siguiente modo:

```
user@mypc:~$ sort palabras.txt > | uniq | grep "mente" | less
```

## Ejemplos de la potencia de los *pipelines*

Procesamos un fichero de texto línea a línea, imprimiendo solo las líneas que contengan la secuencia de caracteres *mente* (vamos a asumir que son palabras susceptibles de ser adverbios en español) y, para facilitar su localización en el texto original, las imprimimos con el número de línea.

```
user@mypc:~$ cat -n texto.txt | grep "mente" 
```

Procesamos un fichero de texto línea a línea, segmentándolo en palabras, buscando aquellas palabras que contengan la cadena *mente*, calculamos su frecuencia y lo redirigimos al paginador.

```
user@mypc:~$ cat texto.txt | tr -sc "a-zA-Z0-9" "\n" | grep "mente" | sort | uniq -c | less
```

Procesamos un fichero de texto línea a línea, segmentándolo en palabras, ordenamos alfabéticamente, contabilizamos frecuencias de aparición, las ordenamos de mayor a menor y las almacenamos en un fichero.

```
user@mypc:~$ cat texto.txt | tr -sc "a-zA-Z0-9" "\n" | sort | uniq -c | sort -nr > texto.pals.frec.txt
```


[^unix4poets]: Church, K. W. *Unix for  poets* http://web.stanford.edu/class/cs124/kwc-unix-for-poets.pdf
